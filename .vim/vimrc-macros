"" vundle: git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
"set rtp+=~/.vim/bundle/vundle/
"call vundle#rc()
"Plugin 'gmarik/vundle'
" https://github.com/Valloric/YouCompleteMe is also interesting, but too much automagic (for me at least)
call pathogen#runtime_append_all_bundles()

""set encoding=latin2
set encoding=utf8
" 4 spaces instead of tabs style spacing
map <F4> <Esc>:set shiftwidth=4<CR>:set softtabstop=4<CR>:set expandtab<CR>
map <F5> <Esc>:setlocal spell spelllang=en_us<CR>
map <F6> <Esc>:setlocal spell spelllang=hu<CR>
map <F7> <Esc>:setlocal nospell<CR>
" handle utf8 files
""map <F8> :set termencoding=iso8859-2<CR>:set encoding=utf8<CR>
map <F8> :set termencoding=utf8<CR>:set encoding=latin2<CR>
" gq should use 72 so that quoted mails are readable on normal terminals
"set tw=72
set formatoptions -=t
au BufNewFile,BufReadPost,BufEnter *.ly so /usr/share/lilypond/2.12.1/vim/syntax/lilypond.vim
set pastetoggle=<F9>
set noshowmatch

au BufRead */swig*/* set tabstop=8 | set shiftwidth=2 | set softtabstop=2 | set expandtab " SWIG
au BufRead */swig*/Source/* set tabstop=8 | set shiftwidth=2 | set softtabstop=2 | set noexpandtab " SWIG Source
au BufNewFile,BufRead *.i set filetype=swig 
au BufNewFile,BufRead *.swg set filetype=swig 

imap <C-F> <ESC>:r!gcontacts -q -t <cword><CR>
map <F11> :set ff=unix<CR>:% !prettyprint<CR>

fun AddTodo()
    " search backwards for our magic regex that works most of the time
    let flags = "bn"
    let fNum = search('^\w\+\s\+\w\+.*\n*\s*[(){:].*[,)]*\s*$', flags)
    " if we're in a python file, search backwards for the most recent def: or
    " class: declaration
    if match(expand("%:t"), ".py") != -1
        let dNum = search('^\s\+def\s*.*:\s*$', flags)
        let cNum = search('^\s*class\s.*:\s*$', flags)
        if dNum > cNum
            let fNum = dNum
        else
            let fNum = cNum
        endif
    endif

    "paste the matching line into a variable to display
    let tempstring = getline(fNum)
    let items = split(tempstring, '(')
    let items2 = split(items[0], ' ')

    "return the line that we found to be the function name
    execute "normal a \<BS>". "\nprintf(\"debug, TODO: " . items2[1] . "\\n\");"
endfun

command Todo call AddTodo()

command XPath XPathSearchPrompt

fun AddTrace()
    execute "normal a \<BS>". "\nOSL_TRACE(\"TODO: %s\", __PRETTY_FUNCTION__);"
endfun
"map <F10> :call AddTrace()<CR>
" Print full path + line number that can be copy&pasted easily.
" See <http://vim.wikia.com/wiki/Get_the_name_of_the_current_file>.
map <F10> :echo expand('%:p').':'.line('.')<CR>

au BufReadCmd *.docx,*.docm,*.dotx,*.dotm,*.xlsx,*.pptx,*.vsdx,*.apk call zip#Browse(expand("<amatch>"))
au BufReadCmd *.odt,*.odm,*.ott,*.ods,*.ots,*.odp,*.otp,*.odg,*.otg,*.oxt,*.odb call zip#Browse(expand("<amatch>"))
au BufReadCmd *.sxw call zip#Browse(expand("<amatch>"))
au BufReadCmd *.k3b call zip#Browse(expand("<amatch>"))
"au FileType xml exe ":silent 1,$!xmllint --format --recover - 2>/dev/null"

" vim -b : edit binary using xxd-format!
augroup Binary
	au!
	au BufReadPre  *.bin let &bin=1
	au BufReadPost *.bin if &bin | %!xxd
	au BufReadPost *.bin set ft=xxd | endif
	au BufWritePre *.bin if &bin | %!xxd -r
	au BufWritePre *.bin endif
	au BufWritePost *.bin if &bin | %!xxd
	au BufWritePost *.bin set nomod | endif
augroup END

" Look in the current directory for "tags", and work up the tree towards root
" until one is found.
set tags=./tags;/

source $VIMRUNTIME/macros/matchit.vim

set maxmempattern=2000

" Fine-tune completion: make it bash-like.
set wildmenu
set wildmode=longest,list

" No indent after namespaces + automatically indent lines inside parentheses.
" http://orchistro.tistory.com/236
set cinoptions=N-s,(0,:0

" auto-disable xpath if necessary
py << EOF
import vim
try:
    import lxml
except ImportError:
    vim.command('let g:skip_xpath = 1')
EOF

" Avoid e.g. the selection created by V automatically end up on the primary
" clipboard.
set clipboard=exclude:.*

" http://andrew.stwrt.ca/posts/project-specific-vimrc/
set exrc
set secure

" Client code for <https://github.com/libclang-vim/libclang-vim>.
fun! ClangInspectType()
    " If you don't have get-compiler-args and just want to try this out, use: system('echo -std=c++1y')
    let compiler_args = system('get-compiler-args '.expand('%:p'))
    let temp_name = tempname() . (&filetype==#'c' ? '.c' : '.cpp')
    if writefile(getbufline(bufnr('%'), 1, '$'), temp_name) == -1
        throw "Could not create a temporary file : ".temp_name
    endif
    let type_info = libclang#deduction#type_at(temp_name, line('.'), col('.'), compiler_args)
    call delete(temp_name)
    " Use '.canonical.type' instead of '.type' if you want e.g.
    " 'std::basic_string<char>', not std::string.
    echo type_info.type
endfun
map <silent><C-i> :call ClangInspectType() <CR>

fun! ClangShowFunc()
    let compiler_args = system('get-compiler-args '.expand('%:p'))
    let temp_name = tempname() . (&filetype==#'c' ? '.c' : '.cpp')
    if writefile(getbufline(bufnr('%'), 1, '$'), temp_name) == -1
        throw "Could not create a temporary file : ".temp_name
    endif
    let info = libclang#deduction#current_function_at(temp_name, line('.'), col('.'), compiler_args)
    call delete(temp_name)
    echo info.name
endfun
map <silent>f :call ClangShowFunc() <CR>

" Code completion PoC.
function! ClangComplete(findstart, base)
    if a:findstart == 1
        " In findstart mode, look for the beginning of the current identifier.
        let l:line = getline('.')
        let l:start = col('.') - 1
        while l:start > 0 && l:line[l:start - 1] =~ '\i'
            let l:start -= 1
        endwhile
        return l:start
    endif

    " Get the current line and column numbers.
    let l:l = line('.')
    let l:c = col('.')

    let compiler_args = system('get-compiler-args '.expand('%:p'))

    let temp_name = tempname() . (&filetype==#'c' ? '.c' : '.cpp')
    if writefile(getbufline(bufnr('%'), 1, '$'), temp_name) == -1
        throw "Could not create a temporary file : ".temp_name
    endif

    let l:matches = split(system('get-completion-at '.temp_name.' '.line('.').' '.col('.').' '.compiler_args), "\n")
    call delete(temp_name)

    " Filter out matches that do not match the prefix we got.
    let l:ret = l:matches
    if a:base != ""
        let l:ret = []
        for l:match in l:matches
            if l:match[:strlen(a:base)-1] == a:base
                let l:ret = l:ret + [l:match]
            endif
        endfor
    endif

    return l:ret
endfunction ClangComplete
autocmd FileType cpp set omnifunc=ClangComplete
" Map Ctrl-Space to Ctrl-X Ctrl-O
imap <C-@> <C-x><C-o>

" vim:set shiftwidth=4 softtabstop=4 expandtab:
